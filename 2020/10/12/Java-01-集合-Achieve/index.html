<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java集合, Halo">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java集合 | Halo</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/apple-touch-icon-next.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Halo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Halo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/medias/featureimages/12.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java集合</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java%E4%B8%AD%E7%BA%A7/" class="post-category">
                                Java中级
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-10-12
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>了解有关Java集合类库的基本知识，以及对典型用法的重点介绍</p>
<p>参考资料:《OnJava8》</p>
<hr>
<blockquote>
<p>如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这是一个非常简单程序。</p>
</blockquote>
<p>通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道确切的类型。为解决这个普遍的编程问题，需要在任意时刻和任意位创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">MyType aReference;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因为你不知道实际上会需要多少这样的引用。</p>
<p>大多数语言都提供某种方法来解决这个基本问题。Java有多种方式进行对象的引用。例如前面曾经学习过的数组，它是编译器支持的类型。数组是保存一组对象的最有效的方式，如果你想保存一组基本类型数据，也推荐使用这种方式。但是数组具有固定的尺寸而在更一般的情况中，你在写程序时并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制显得过于受限了。</p>
<p>Java 实用类库还提供了一套相当完整的容器类来解决这个问题，其中基本的类型是<strong>List</strong>、<strong>Set</strong>、 <strong>Queue</strong>和<strong>Map</strong>。这些对象类型也称为集合类，集合提供了完善的方法来保存对象，你可以使用这些工具来解决数量惊人的问题。</p>
<p>集合还有其他一些特性。例如，<strong>Set</strong>对于每个值都只保存一个对象，<strong>Map</strong>是允许你将某些对象与其他一些对象关联起来的关联数组，Java 集合类都可以自动地调整自己的尺寸。因此，与数组不同，在编程时，你可以将任意数量的对象放置到集合中，并且不需要担心集合应该设置为多大。</p>
<p>即使在Java中没有直接的关键字支持，集合类仍旧是可以显著增强你的编程能力的基本工具。</p>
<h2 id="泛型和类型安全的集合"><a href="#泛型和类型安全的集合" class="headerlink" title="泛型和类型安全的集合"></a>泛型和类型安全的集合</h2><p>使用 Java 5之前的集合的一个主要问题就是编译器允许你向集合中插入不正确的类型。例如，考虑一个 Apple对象的集合，我们使用最基本最可靠的集合 <strong>ArrayList</strong>。现在，你可以把<strong>ArrayList</strong>当作“可以自动扩充自身尺寸的数组”来看待。使用 <strong>ArrayList</strong>相当简单：创建一个实例，用<code>add()</code>插入对象；然后用<code>get()</code>访问这些对象，此时需要使用索引，就像数组一样，但是不需要方括号。 <strong>ArrayList</strong>还有一个 <code>size()</code>方法，使你可以知道已经有多少元素添加了进来，从而不会不小心因索引越界而引发错误。</p>
<p>在本例中， <strong>Apple</strong>和 <strong>Orange</strong>都放置在了集合中，然后将它们取出。正常情况下，Java编译器会报告警告信息，因为这个示例没有使用泛型。在这里，我们使用特定的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的<code>@SuppressWarnings</code>注解及其参数表示只抑制“unchecked（不受检查的异常）”类型的警告信息：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;ApplesAndOrangesWithoutGenerics.java
&#x2F;&#x2F; Simple collection use (suppressing compiler warnings)
&#x2F;&#x2F; &#123;ThrowsException&#125;
import java.util.*;

class Apple &#123;
  private static long counter;
  private final long id &#x3D; counter++;
  public long id() &#123; return id; &#125;
&#125;

class Orange &#123;&#125;

public class ApplesAndOrangesWithoutGenerics &#123;
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void main(String[] args) &#123;
    ArrayList apples &#x3D; new ArrayList();
    for(int i &#x3D; 0; i &lt; 3; i++)
      apples.add(new Apple());
    &#x2F;&#x2F; No problem adding an Orange to apples:
    apples.add(new Orange());
    for(Object apple : apples) &#123;
      ((Apple) apple).id();
      &#x2F;&#x2F; Orange is detected only at run time
    &#125;
  &#125;
&#125;
&#x2F;* Output:
___[ Error Output ]___
Exception in thread &quot;main&quot;
java.lang.ClassCastException: Orange cannot be cast to
Apple
        at ApplesAndOrangesWithoutGenerics.main(ApplesA
ndOrangesWithoutGenerics.java:23)
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Apple</strong> 和 <strong>Orange</strong> 是截然不同的，它们除了都是 <strong>Object</strong> 之外没有任何共同点（如果一个类没有显式地声明继承自哪个类，那么它就自动继承自 <strong>Object</strong>）。因为 <strong>ArrayList</strong> 保存的是 <strong>Object</strong> ，所以不仅可以通过 <strong>ArrayList</strong> 的 <code>add()</code> 方法将 <strong>Apple</strong> 对象放入这个集合，而且可以放入 <strong>Orange</strong> 对象，这无论在编译期还是运行时都不会有问题。当使用 <strong>ArrayList</strong> 的 <code>get()</code> 方法来取出你认为是 <strong>Apple</strong> 的对象时，得到的只是 <strong>Object</strong> 引用，必须将其转型为 <strong>Apple</strong>。然后需要将整个表达式用括号括起来，以便在调用 <strong>Apple</strong> 的 <code>id()</code> 方法之前，强制执行转型。否则，将会产生语法错误。</p>
<p>在运行时，当尝试将 <strong>Orange</strong> 对象转为 <strong>Apple</strong> 时，会出现输出中显示的错误。</p>
<p> Java 泛型来创建类可能很复杂。但是，使用预先定义的泛型类却相当简单。例如，要定义一个用于保存 <strong>Apple</strong> 对象的 <strong>ArrayList</strong> ，只需要使用 <strong>ArrayList&lt;Apple&gt;</strong> 来代替 <strong>ArrayList</strong> 。尖括号括起来的是<em>类型参数</em>（可能会有多个），它指定了这个集合实例可以保存的类型。</p>
<p>通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。下面还是这个示例，但是使用了泛型：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;ApplesAndOrangesWithGenerics.java
import java.util.*;

public class ApplesAndOrangesWithGenerics &#123;
  public static void main(String[] args) &#123;
    ArrayList&lt;Apple&gt; apples &#x3D; new ArrayList&lt;&gt;();
    for(int i &#x3D; 0; i &lt; 3; i++)
      apples.add(new Apple());
    &#x2F;&#x2F; Compile-time error:
    &#x2F;&#x2F; apples.add(new Orange());
    for(Apple apple : apples) &#123;
      System.out.println(apple.id());
    &#125;
  &#125;
&#125;
&#x2F;* Output:
0
1
2
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <strong>apples</strong> 定义的右侧，可以看到 <code>new ArrayList&lt;&gt;()</code> 。这有时被称为“菱形语法”（diamond syntax）。在 Java 7 之前，必须要在两端都进行类型声明，如下所示：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;Apple&gt; apples &#x3D; new ArrayList&lt;Apple&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然<em>类型推断</em>（type inference）只是个很小的请求，Java 语言团队仍然欣然接受并进行了改进。</p>
<p>有了 <strong>ArrayList</strong> 声明中的类型指定，编译器会阻止将 <strong>Orange</strong> 放入 <strong>apples</strong> ，因此，这会成为一个编译期错误而不是运行时错误。</p>
<p>使用泛型，从 <strong>List</strong> 中获取元素不需要强制类型转换。因为 <strong>List</strong> 知道它持有什么类型，因此当调用 <code>get()</code> 时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。</p>
<p>当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;GenericsAndUpcasting.java
import java.util.*;

class GrannySmith extends Apple &#123;&#125;
class Gala extends Apple &#123;&#125;
class Fuji extends Apple &#123;&#125;
class Braeburn extends Apple &#123;&#125;

public class GenericsAndUpcasting &#123;
  public static void main(String[] args) &#123;
    ArrayList&lt;Apple&gt; apples &#x3D; new ArrayList&lt;&gt;();
    apples.add(new GrannySmith());
    apples.add(new Gala());
    apples.add(new Fuji());
    apples.add(new Braeburn());
    for(Apple apple : apples)
      System.out.println(apple);
  &#125;
&#125;
&#x2F;* Output:
GrannySmith@15db9742
Gala@6d06d69c
Fuji@7852e922
Braeburn@4e25154f
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此，可以将 <strong>Apple</strong> 的子类型添加到被指定为保存 <strong>Apple</strong> 对象的集合中。</p>
<p>程序的输出是从 <strong>Object</strong> 默认的 <code>toString()</code> 方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（这个散列码是通过 <code>hashCode()</code> 方法产生的）。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：</p>
<ol>
<li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li>
<li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li>
</ol>
<p>尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 <strong>List</strong> ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Apple&gt; apples &#x3D; new ArrayList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请注意， <strong>ArrayList</strong> 已经被向上转型为了 <strong>List</strong> ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：</p>
<p>TODO ： 暂不理解“使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了”这句话的意义。2020年10月12日</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Apple&gt; apples &#x3D; new LinkedList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。</p>
<p>这种方式并非总是有效的，因为某些具体类有额外的功能。例如， <strong>LinkedList</strong> 具有 <strong>List</strong> 接口中未包含的额外方法，而 <strong>TreeMap</strong> 也具有在 <strong>Map</strong> 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。</p>
<p><strong>Collection</strong> 接口概括了序列的概念——一种存放一组对象的方式。下面是个简单的示例，用 <strong>Integer</strong> 对象填充了一个 <strong>Collection</strong> （这里用 <strong>ArrayList</strong> 表示），然后打印集合中的每个元素：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;SimpleCollection.java
import java.util.*;

public class SimpleCollection &#123;
  public static void main(String[] args) &#123;
    Collection&lt;Integer&gt; c &#x3D; new ArrayList&lt;&gt;();
    for(int i &#x3D; 0; i &lt; 10; i++)
      c.add(i); &#x2F;&#x2F; Autoboxing
    for(Integer i : c)
      System.out.print(i + &quot;, &quot;);
  &#125;
&#125;
&#x2F;* Output:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子仅使用了 <strong>Collection</strong> 中的方法（即 <code>add()</code> ），所以使用任何继承自 <strong>Collection</strong> 的类的对象都可以正常工作。但是 <strong>ArrayList</strong> 是最基本的序列类型。</p>
<p><code>add()</code> 方法的名称就表明它是在 <strong>Collection</strong> 中添加一个新元素。但是，文档中非常详细地叙述到 <code>add()</code> “要确保这个 <strong>Collection</strong> 包含指定的元素。”这是因为考虑到了 <strong>Set</strong> 的含义，因为在 <strong>Set</strong>中，只有当元素不存在时才会添加元素。在使用 <strong>ArrayList</strong> ，或任何其他类型的 <strong>List</strong> 时，<code>add()</code> 总是表示“把它放进去”，因为 <strong>List</strong> 不关心是否存在重复元素。</p>
<p>TODO ：不理解“要确保这个 <strong>Collection</strong> 包含指定的元素。”的必要。2020年10月12日</p>
<p>可以使用 <em>for-in</em> 语法来遍历所有的 <strong>Collection</strong> ，就像这里所展示的那样。在本章的后续部分，还将学习到一个更灵活的概念，<em>迭代器</em>。</p>
<h2 id="添加元素组"><a href="#添加元素组" class="headerlink" title="添加元素组"></a>添加元素组</h2><p>TODO ：此小节不理解。2020年10月12日</p>
<p>在 <strong>java.util</strong> 包中的 <strong>Arrays</strong> 和 <strong>Collections</strong> 类中都有很多实用的方法，可以在一个 <strong>Collection</strong> 中添加一组元素。</p>
<p><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。 <code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。下边的示例展示了这两个方法，以及更通用的 、所有 <strong>Collection</strong> 类型都包含的<code>addAll()</code> 方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;AddingGroups.java
&#x2F;&#x2F; Adding groups of elements to Collection objects
import java.util.*;

public class AddingGroups &#123;
  public static void main(String[] args) &#123;
    Collection&lt;Integer&gt; collection &#x3D;
      new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));
    Integer[] moreInts &#x3D; &#123; 6, 7, 8, 9, 10 &#125;;
    collection.addAll(Arrays.asList(moreInts));
    &#x2F;&#x2F; Runs significantly faster, but you can&#39;t
    &#x2F;&#x2F; construct a Collection this way:
    Collections.addAll(collection, 11, 12, 13, 14, 15);
    Collections.addAll(collection, moreInts);
    &#x2F;&#x2F; Produces a list &quot;backed by&quot; an array:
    List&lt;Integer&gt; list &#x3D; Arrays.asList(16,17,18,19,20);
    list.set(1, 99); &#x2F;&#x2F; OK -- modify an element
    &#x2F;&#x2F; list.add(21); &#x2F;&#x2F; Runtime error; the underlying
                     &#x2F;&#x2F; array cannot be resized.
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Collection</strong> 的构造器可以接受另一个 <strong>Collection</strong>，用它来将自身初始化。因此，可以使用 <code>Arrays.asList()</code> 来为这个构造器产生输入。但是， <code>Collections.addAll()</code> 运行得更快，而且很容易构建一个不包含元素的 <strong>Collection</strong> ，然后调用 <code>Collections.addAll()</code> ，因此这是首选方式。</p>
<p><code>Collection.addAll()</code> 方法只能接受另一个 <strong>Collection</strong> 作为参数，因此它没有 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code> 灵活。这两个方法都使用可变参数列表。</p>
<p>也可以直接使用 <code>Arrays.asList()</code> 的输出作为一个 <strong>List</strong> ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 <strong>List</strong> 上调用 <code>add()</code> 或 <code>remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;AsListInference.java
import java.util.*;

class Snow &#123;&#125;
class Powder extends Snow &#123;&#125;
class Light extends Powder &#123;&#125;
class Heavy extends Powder &#123;&#125;
class Crusty extends Snow &#123;&#125;
class Slush extends Snow &#123;&#125;

public class AsListInference &#123;
  public static void main(String[] args) &#123;
    List&lt;Snow&gt; snow1 &#x3D; Arrays.asList(
      new Crusty(), new Slush(), new Powder());
    &#x2F;&#x2F;- snow1.add(new Heavy()); &#x2F;&#x2F; Exception

    List&lt;Snow&gt; snow2 &#x3D; Arrays.asList(
      new Light(), new Heavy());
    &#x2F;&#x2F;- snow2.add(new Slush()); &#x2F;&#x2F; Exception

    List&lt;Snow&gt; snow3 &#x3D; new ArrayList&lt;&gt;();
    Collections.addAll(snow3,
      new Light(), new Heavy(), new Powder());
    snow3.add(new Crusty());

    &#x2F;&#x2F; Hint with explicit type argument specification:
    List&lt;Snow&gt; snow4 &#x3D; Arrays.&lt;Snow&gt;asList(
       new Light(), new Heavy(), new Slush());
    &#x2F;&#x2F;- snow4.add(new Powder()); &#x2F;&#x2F; Exception
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <strong>snow4</strong> 中，注意 <code>Arrays.asList()</code> 中间的“暗示”（即 <code>&lt;Snow&gt;</code> ），告诉编译器 <code>Arrays.asList()</code> 生成的结果 <strong>List</strong> 类型的实际目标类型是什么。这称为<em>显式类型参数说明</em>（explicit type argument specification）。</p>
<h2 id="集合的打印"><a href="#集合的打印" class="headerlink" title="集合的打印"></a>集合的打印</h2><p>必须使用 <code>Arrays.toString()</code> 来生成数组的可打印形式。但是打印集合无需任何帮助。下面是一个例子，这个例子中也介绍了基本的Java集合：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;PrintingCollections.java
&#x2F;&#x2F; Collections print themselves automatically
import java.util.*;

public class PrintingCollections &#123;
  static Collection fill(Collection&lt;String&gt; collection) &#123;
    collection.add(&quot;rat&quot;);
    collection.add(&quot;cat&quot;);
    collection.add(&quot;dog&quot;);
    collection.add(&quot;dog&quot;);
    return collection;
  &#125;
  static Map fill(Map&lt;String, String&gt; map) &#123;
    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);
    map.put(&quot;cat&quot;, &quot;Rags&quot;);
    map.put(&quot;dog&quot;, &quot;Bosco&quot;);
    map.put(&quot;dog&quot;, &quot;Spot&quot;);
    return map;
  &#125;
  public static void main(String[] args) &#123;
    System.out.println(fill(new ArrayList&lt;&gt;()));
    System.out.println(fill(new LinkedList&lt;&gt;()));
    System.out.println(fill(new HashSet&lt;&gt;()));
    System.out.println(fill(new TreeSet&lt;&gt;()));
    System.out.println(fill(new LinkedHashSet&lt;&gt;()));
    System.out.println(fill(new HashMap&lt;&gt;()));
    System.out.println(fill(new TreeMap&lt;&gt;()));
    System.out.println(fill(new LinkedHashMap&lt;&gt;()));
  &#125;
&#125;
&#x2F;* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[rat, cat, dog]
[cat, dog, rat]
[rat, cat, dog]
&#123;rat&#x3D;Fuzzy, cat&#x3D;Rags, dog&#x3D;Spot&#125;
&#123;cat&#x3D;Rags, dog&#x3D;Spot, rat&#x3D;Fuzzy&#125;
&#123;rat&#x3D;Fuzzy, cat&#x3D;Rags, dog&#x3D;Spot&#125;
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这显示了Java集合库中的两个主要类型。它们的区别在于集合中的每个“槽”（slot）保存的元素个数。 <strong>Collection</strong> 类型在每个槽中只能保存一个元素。此类集合包括： <strong>List</strong> ，它以特定的顺序保存一组元素； <strong>Set</strong> ，其中元素不允许重复； <strong>Queue</strong> ，只能在集合一端插入对象，并从另一端移除对象（就本例而言，这只是查看序列的另一种方式，因此并没有显示它）。 <strong>Map</strong> 在每个槽中存放了两个元素，即键和与之关联的值。</p>
<p>默认的打印行为，使用集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。</p>
<p>第一个 <code>fill()</code> 方法适用于所有类型的 <strong>Collection</strong> ，这些类型都实现了 <code>add()</code> 方法以添加新元素。</p>
<p><strong>ArrayList</strong> 和 <strong>LinkedList</strong> 都是 <strong>List</strong> 的类型，从输出中可以看出，它们都按插入顺序保存元素。两者之间的区别不仅在于执行某些类型的操作时的性能，而且 <strong>LinkedList</strong> 包含的操作多于 <strong>ArrayList</strong> 。本章后面将对这些内容进行更全面的探讨。</p>
<p><strong>HashSet</strong> ， <strong>TreeSet</strong> 和 <strong>LinkedHashSet</strong> 是 <strong>Set</strong> 的类型。从输出中可以看到， <strong>Set</strong> 仅保存每个相同项中的一个，并且不同的 <strong>Set</strong> 实现存储元素的方式也不同。 <strong>HashSet</strong> 使用相当复杂的方法存储元素。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 <strong>Set</strong> 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 <strong>TreeSet</strong> ，它将按比较结果的升序保存对象）或 <strong>LinkedHashSet</strong> ，它按照被添加的先后顺序保存对象。</p>
<p><strong>Map</strong> （也称为关联数组）使用键来查找对象，就像一个简单的数据库。所关联的对象称为值。 假设有一个 <strong>Map</strong> 将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以用“Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键， <strong>Map</strong> 只存储一次。</p>
<p><code>Map.put(key, value)</code> 添加一个所想要添加的值并将它与一个键（用来查找值）相关联。 <code>Map.get(key)</code> 生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍后展示。</p>
<p>请注意，这里没有指定（或考虑） <strong>Map</strong> 的大小，因为它会自动调整大小。 此外， <strong>Map</strong> 还知道如何打印自己，它会显示相关联的键和值。</p>
<p>本例使用了 <strong>Map</strong> 的三种基本风格： <strong>HashMap</strong> ， <strong>TreeMap</strong> 和 <strong>LinkedHashMap</strong> 。</p>
<p>键和值保存在 <strong>HashMap</strong> 中的顺序不是插入顺序，因为 <strong>HashMap</strong> 实现使用了非常快速的算法来控制顺序。 <strong>TreeMap</strong> 通过比较结果的升序来保存键， <strong>LinkedHashMap</strong> 在保持 <strong>HashMap</strong> 查找速度的同时按键的插入顺序保存键。</p>
<h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p>
<p>有两种类型的 <strong>List</strong> ：</p>
<ul>
<li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li>
<li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</li>
</ul>
<p>TODO ：特征集？2020年10月12日</p>
<p>下面的示例导入 <strong>typeinfo.pets</strong> ，超前使用了类型信息一章中的类库。这个类库包含了 <strong>Pet</strong> 类层次结构，以及用于随机生成 <strong>Pet</strong> 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：</p>
<ol>
<li>有一个 <strong>Pet</strong> 类，以及 <strong>Pet</strong> 的各种子类型。</li>
<li>静态的 <code>Pets.arrayList()</code> 方法返回一个填充了随机选取的 <strong>Pet</strong> 对象的 <strong>ArrayList</strong>：</li>
</ol>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; collections&#x2F;ListFeatures.java
import typeinfo.pets.*;
import java.util.*;

public class ListFeatures &#123;
  public static void main(String[] args) &#123;
    Random rand &#x3D; new Random(47);
    List&lt;Pet&gt; pets &#x3D; Pets.list(7);
    System.out.println(&quot;1: &quot; + pets);
    Hamster h &#x3D; new Hamster();
    pets.add(h); &#x2F;&#x2F; Automatically resizes
    System.out.println(&quot;2: &quot; + pets);
    System.out.println(&quot;3: &quot; + pets.contains(h));
    pets.remove(h); &#x2F;&#x2F; Remove by object
    Pet p &#x3D; pets.get(2);
    System.out.println(&quot;4: &quot; +  p + &quot; &quot; + pets.indexOf(p));
    Pet cymric &#x3D; new Cymric();
    System.out.println(&quot;5: &quot; + pets.indexOf(cymric));
    System.out.println(&quot;6: &quot; + pets.remove(cymric));
    &#x2F;&#x2F; Must be the exact object:
    System.out.println(&quot;7: &quot; + pets.remove(p));
    System.out.println(&quot;8: &quot; + pets);
    pets.add(3, new Mouse()); &#x2F;&#x2F; Insert at an index
    System.out.println(&quot;9: &quot; + pets);
    List&lt;Pet&gt; sub &#x3D; pets.subList(1, 4);
    System.out.println(&quot;subList: &quot; + sub);
    System.out.println(&quot;10: &quot; + pets.containsAll(sub));
    Collections.sort(sub); &#x2F;&#x2F; In-place sort
    System.out.println(&quot;sorted subList: &quot; + sub);
    &#x2F;&#x2F; Order is not important in containsAll():
    System.out.println(&quot;11: &quot; + pets.containsAll(sub));
    Collections.shuffle(sub, rand); &#x2F;&#x2F; Mix it up
    System.out.println(&quot;shuffled subList: &quot; + sub);
    System.out.println(&quot;12: &quot; + pets.containsAll(sub));
    List&lt;Pet&gt; copy &#x3D; new ArrayList&lt;&gt;(pets);
    sub &#x3D; Arrays.asList(pets.get(1), pets.get(4));
    System.out.println(&quot;sub: &quot; + sub);
    copy.retainAll(sub);
    System.out.println(&quot;13: &quot; + copy);
    copy &#x3D; new ArrayList&lt;&gt;(pets); &#x2F;&#x2F; Get a fresh copy
    copy.remove(2); &#x2F;&#x2F; Remove by index
    System.out.println(&quot;14: &quot; + copy);
    copy.removeAll(sub); &#x2F;&#x2F; Only removes exact objects
    System.out.println(&quot;15: &quot; + copy);
    copy.set(1, new Mouse()); &#x2F;&#x2F; Replace an element
    System.out.println(&quot;16: &quot; + copy);
    copy.addAll(2, sub); &#x2F;&#x2F; Insert a list in the middle
    System.out.println(&quot;17: &quot; + copy);
    System.out.println(&quot;18: &quot; + pets.isEmpty());
    pets.clear(); &#x2F;&#x2F; Remove all elements
    System.out.println(&quot;19: &quot; + pets);
    System.out.println(&quot;20: &quot; + pets.isEmpty());
    pets.addAll(Pets.list(4));
    System.out.println(&quot;21: &quot; + pets);
    Object[] o &#x3D; pets.toArray();
    System.out.println(&quot;22: &quot; + o[3]);
    Pet[] pa &#x3D; pets.toArray(new Pet[0]);
    System.out.println(&quot;23: &quot; + pa[3].id());
  &#125;
&#125;
&#x2F;* Output:
1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]
2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]
3: true
4: Cymric 2
5: -1
6: false
7: true
8: [Rat, Manx, Mutt, Pug, Cymric, Pug]
9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]
subList: [Manx, Mutt, Mouse]
10: true
sorted subList: [Manx, Mouse, Mutt]
11: true
shuffled subList: [Mouse, Manx, Mutt]
12: true
sub: [Mouse, Pug]
13: [Mouse, Pug]
14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]
15: [Rat, Mutt, Cymric, Pug]
16: [Rat, Mouse, Cymric, Pug]
17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]
18: false
19: []
20: true
21: [Manx, Cymric, Rat, EgyptianMau]
22: EgyptianMau
23: 14
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 <strong>Pet</strong> 组成的 <strong>List</strong> 。 与数组不同， <strong>List</strong> 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 <strong>Hamster</strong> 的结果，该对象将被追加到列表的末尾。</p>
<p>可以使用 <code>contains()</code> 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 <code>remove()</code> 方法。同样，如果有一个对象的引用，可以使用 <code>indexOf()</code> 在 <strong>List</strong> 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。</p>
<p>当确定元素是否是属于某个 <strong>List</strong> ，寻找某个元素的索引，以及通过引用从 <strong>List</strong> 中删除元素时，都会用到 <code>equals()</code> 方法（根类 <strong>Object</strong> 的一个方法）。每个 <strong>Pet</strong> 被定义为一个唯一的对象，所以即使列表中已经有两个 <strong>Cymrics</strong> ，如果再创建一个新的 <strong>Cymric</strong> 对象并将其传递给 <code>indexOf()</code> 方法，结果仍为 <strong>-1</strong> （表示未找到），并且尝试调用 <code>remove()</code> 方法来删除这个对象将返回 <strong>false</strong> 。对于其他类， <code>equals()</code> 的定义可能有所不同。例如，如果两个 <strong>String</strong> 的内容相同，则这两个 <strong>String</strong> 相等。因此，为了防止出现意外，请务必注意 <strong>List</strong> 行为会根据 <code>equals()</code> 行为而发生变化。</p>
<p>第 7、8 行输出展示了删除与 <strong>List</strong> 中的对象完全匹配的对象是成功的。</p>
<p>可以在 <strong>List</strong> 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 <strong>LinkedList</strong> ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 <strong>ArrayList</strong> ，这可是代价高昂的操作。这是否意味着永远不应该在 <strong>ArrayList</strong> 的中间插入元素，并最好是转换为 <strong>LinkedList</strong> ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 <strong>ArrayList</strong> 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 <strong>List</strong> 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。</p>
<p><code>subList()</code> 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 <code>containsAll()</code> 方法时，很自然地会得到 <strong>true</strong>。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 <strong>sub</strong> 上调用直观命名的 <code>Collections.sort()</code> 和 <code>Collections.shuffle()</code> 方法，不会影响 <code>containsAll()</code> 的结果。 <code>subList()</code> 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。</p>
<p><code>retainAll()</code> 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 <strong>copy</strong> 和 <strong>sub</strong> 中的所有元素。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</p>
<p>第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 <code>equals()</code> 的行为。</p>
<p><code>removeAll()</code> 方法也是基于 <code>equals()</code> 方法运行的。 顾名思义，它会从 <strong>List</strong> 中删除在参数 <strong>List</strong> 中的所有元素。</p>
<p><code>set()</code> 方法的命名显得很不合时宜，因为它与 <strong>Set</strong> 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。</p>
<p>第 17 行输出表明，对于 <strong>List</strong> ，有一个重载的 <code>addAll()</code> 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 <strong>Collection</strong> 的 <code>addAll()</code> 方法将其追加到列表的末尾。</p>
<p>第 18 - 20 行输出展示了 <code>isEmpty()</code> 和 <code>clear()</code> 方法的效果。</p>
<p>第 22、23 行输出展示了如何使用 <code>toArray()</code> 方法将任意的 <strong>Collection</strong> 转换为数组。这是一个重载方法，其无参版本返回一个 <strong>Object</strong> 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 <strong>List</strong> 中的所有元素（就像本例一样），则 <code>toArray()</code> 会创建一个具有合适尺寸的新数组。 <strong>Pet</strong> 对象有一个 <code>id()</code> 方法，可以在所产生的数组中的对象上调用这个方法。</p>
<h2 id="迭代器Iterators"><a href="#迭代器Iterators" class="headerlink" title="迭代器Iterators"></a>迭代器Iterators</h2><p>在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 <strong>List</strong> ， <code>add()</code> 是插入元素的一种方式， <code>get()</code> 是获取元素的一种方式。</p>
<p>如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 <strong>List</strong> 编码的，但是后来发现如果能够将相同的代码应用于 <strong>Set</strong> 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？</p>
<p>迭代器（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p>
<ol>
<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>
<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>
</ol>
<p>为了观察它的工作方式，这里再次使用 <strong>Pet</strong> 工具：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;SimpleIteration.java
import typeinfo.pets.*;
import java.util.*;

public class SimpleIteration &#123;
  public static void main(String[] args) &#123;
    List&lt;Pet&gt; pets &#x3D; Pets.list(12);
    Iterator&lt;Pet&gt; it &#x3D; pets.iterator();
    while(it.hasNext()) &#123;
      Pet p &#x3D; it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    &#125;
    System.out.println();
    &#x2F;&#x2F; A simpler approach, when possible:
    for(Pet p : pets)
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    System.out.println();
    &#x2F;&#x2F; An Iterator can also remove elements:
    it &#x3D; pets.iterator();
    for(int i &#x3D; 0; i &lt; 6; i++) &#123;
      it.next();
      it.remove();
    &#125;
    System.out.println(pets);
  &#125;
&#125;
&#x2F;* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster
[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了 <strong>Iterator</strong> ，就不必再为集合中元素的数量操心了。这是由 <code>hasNext()</code> 和 <code>next()</code> 关心的事情。</p>
<p>如果只是想向前遍历 <strong>List</strong> ，并不打算修改 <strong>List</strong> 对象本身，那么使用 for-in 语法更加简洁。</p>
<p><strong>Iterator</strong> 还可以删除由 <code>next()</code> 生成的最后一个元素，这意味着在调用 <code>remove()</code> 之前必须先调用 <code>next()</code> 。[^4]</p>
<p>在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。</p>
<p>现在考虑创建一个 <code>display()</code> 方法，它不必知晓集合的确切类型：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;CrossCollectionIteration.java
import typeinfo.pets.*;
import java.util.*;

public class CrossCollectionIteration &#123;
  public static void display(Iterator&lt;Pet&gt; it) &#123;
    while(it.hasNext()) &#123;
      Pet p &#x3D; it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    &#125;
    System.out.println();
  &#125;
  public static void main(String[] args) &#123;
    List&lt;Pet&gt; pets &#x3D; Pets.list(8);
    LinkedList&lt;Pet&gt; petsLL &#x3D; new LinkedList&lt;&gt;(pets);
    HashSet&lt;Pet&gt; petsHS &#x3D; new HashSet&lt;&gt;(pets);
    TreeSet&lt;Pet&gt; petsTS &#x3D; new TreeSet&lt;&gt;(pets);
    display(pets.iterator());
    display(petsLL.iterator());
    display(petsHS.iterator());
    display(petsTS.iterator());
  &#125;
&#125;
&#x2F;* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx
5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>display()</code> 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 <strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p>
<p>我们可以使用 <strong>Iterable</strong> 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 <strong>Iterator</strong> 的任何东西”：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;CrossCollectionIteration2.java
import typeinfo.pets.*;
import java.util.*;

public class CrossCollectionIteration2 &#123;
  public static void display(Iterable&lt;Pet&gt; ip) &#123;
    Iterator&lt;Pet&gt; it &#x3D; ip.iterator();
    while(it.hasNext()) &#123;
      Pet p &#x3D; it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    &#125;
    System.out.println();
  &#125;
  public static void main(String[] args) &#123;
    List&lt;Pet&gt; pets &#x3D; Pets.list(8);
    LinkedList&lt;Pet&gt; petsLL &#x3D; new LinkedList&lt;&gt;(pets);
    HashSet&lt;Pet&gt; petsHS &#x3D; new HashSet&lt;&gt;(pets);
    TreeSet&lt;Pet&gt; petsTS &#x3D; new TreeSet&lt;&gt;(pets);
    display(pets);
    display(petsLL);
    display(petsHS);
    display(petsTS);
  &#125;
&#125;
&#x2F;* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat 
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里所有的类都是 <strong>Iterable</strong> ，所以现在对 <code>display()</code> 的调用显然更简单。</p>
<h2 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h2><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。 下面的示例演示了所有这些能力：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;ListIteration.java
import typeinfo.pets.*;
import java.util.*;

public class ListIteration &#123;
  public static void main(String[] args) &#123;
    List&lt;Pet&gt; pets &#x3D; Pets.list(8);
    ListIterator&lt;Pet&gt; it &#x3D; pets.listIterator();
    while(it.hasNext())
      System.out.print(it.next() +
        &quot;, &quot; + it.nextIndex() +
        &quot;, &quot; + it.previousIndex() + &quot;; &quot;);
    System.out.println();
    &#x2F;&#x2F; Backwards:
    while(it.hasPrevious())
      System.out.print(it.previous().id() + &quot; &quot;);
    System.out.println();
    System.out.println(pets);
    it &#x3D; pets.listIterator(3);
    while(it.hasNext()) &#123;
      it.next();
      it.set(Pets.get());
    &#125;
    System.out.println(pets);
  &#125;
&#125;
&#x2F;* Output:
Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7; 
7 6 5 4 3 2 1 0 
[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]
[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Pets.get()</code> 方法用来从位置 3 开始替换 <strong>List</strong> 中的所有 Pet 对象。</p>
<h2 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h2><p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p>
<p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p>
<ul>
<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>
<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>
</ul>
<p>下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 <strong>ListFeatures.java</strong> 中所示的行为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;LinkedListFeatures.java
import typeinfo.pets.*;
import java.util.*;

public class LinkedListFeatures &#123;
    public static void main(String[] args) &#123;
        LinkedList&lt;Pet&gt; pets &#x3D; new LinkedList&lt;&gt;(Pets.list(5));
        System.out.println(pets);
        &#x2F;&#x2F; Identical:
        System.out.println(&quot;pets.getFirst(): &quot; + pets.getFirst());
        System.out.println(&quot;pets.element(): &quot; + pets.element());
        &#x2F;&#x2F; Only differs in empty-list behavior:
        System.out.println(&quot;pets.peek(): &quot; + pets.peek());
        &#x2F;&#x2F; Identical; remove and return the first element:
        System.out.println(&quot;pets.remove(): &quot; + pets.remove());
        System.out.println(&quot;pets.removeFirst(): &quot; + pets.removeFirst());
        &#x2F;&#x2F; Only differs in empty-list behavior:
        System.out.println(&quot;pets.poll(): &quot; + pets.poll());
        System.out.println(pets);
        pets.addFirst(new Rat());
        System.out.println(&quot;After addFirst(): &quot; + pets);
        pets.offer(Pets.get());
        System.out.println(&quot;After offer(): &quot; + pets);
        pets.add(Pets.get());
        System.out.println(&quot;After add(): &quot; + pets);
        pets.addLast(new Hamster());
        System.out.println(&quot;After addLast(): &quot; + pets);
        System.out.println(&quot;pets.removeLast(): &quot; + pets.removeLast());
    &#125;
&#125;
&#x2F;* Output:
[Rat, Manx, Cymric, Mutt, Pug]
pets.getFirst(): Rat
pets.element(): Rat
pets.peek(): Rat
pets.remove(): Rat
pets.removeFirst(): Manx
pets.poll(): Cymric
[Mutt, Pug]
After addFirst(): [Rat, Mutt, Pug]
After offer(): [Rat, Mutt, Pug, Cymric]
After add(): [Rat, Mutt, Pug, Cymric, Pug]
After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]
pets.removeLast(): Hamster
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Pets.list()</code> 的结果被传递给 <strong>LinkedList</strong> 的构造器，以便使用它来填充 <strong>LinkedList</strong> 。如果查看 <strong>Queue</strong> 接口就会发现，它在 <strong>LinkedList</strong> 的基础上添加了 <code>element()</code> ， <code>offer()</code> ， <code>peek()</code> ， <code>poll()</code> 和 <code>remove()</code> 方法，以使其可以成为一个 <strong>Queue</strong> 的实现。 </p>
<h2 id="堆栈Stack"><a href="#堆栈Stack" class="headerlink" title="堆栈Stack"></a>堆栈Stack</h2><p>堆栈是“后进先出”（LIFO）集合。它有时被称为叠加栈（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。</p>
<p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;StackTest.java
import java.util.*;

public class StackTest &#123;
    public static void main(String[] args) &#123;
        Deque&lt;String&gt; stack &#x3D; new ArrayDeque&lt;&gt;();
        for (String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) &#123;
            stack.push(s);
        &#125;
        while (!stack.isEmpty()) &#123;
            System.out.print(stack.pop() + &quot; &quot;);
        &#125;
    &#125;
&#125;
&#x2F;* Output:
fleas has dog My
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使它是作为一个堆栈在使用，我们仍然必须将其声明为 <strong>Deque</strong> 。有时一个名为 <strong>Stack</strong> 的类更能把事情讲清楚：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; onjava&#x2F;Stack.java
&#x2F;&#x2F; A Stack class built with an ArrayDeque
package onjava;
import java.util.Deque;
import java.util.ArrayDeque;

public class Stack&lt;T&gt; &#123;
  private Deque&lt;T&gt; storage &#x3D; new ArrayDeque&lt;&gt;();
  public void push(T v) &#123; storage.push(v); &#125;
  public T peek() &#123; return storage.peek(); &#125;
  public T pop() &#123; return storage.pop(); &#125;
  public boolean isEmpty() &#123; return storage.isEmpty(); &#125;
  @Override
  public String toString() &#123;
    return storage.toString();
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 告诉编译器这是一个参数化类型，而其中的类型参数 <strong>T</strong> 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 <strong>T</strong> 类型对象的 <strong>Stack</strong> 。” <strong>Stack</strong> 是使用 <strong>ArrayDeque</strong> 实现的，而 <strong>ArrayDeque</strong> 也被告知它将持有 <strong>T</strong> 类型对象。注意， <code>push()</code> 接受类型为 <strong>T</strong> 的对象，而 <code>peek()</code> 和 <code>pop()</code> 返回类型为 <strong>T</strong> 的对象。 <code>peek()</code> 方法将返回栈顶元素，但并不将其从栈顶删除，而 <code>pop()</code> 删除并返回顶部元素。</p>
<p>如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类（<strong>Java 1.0</strong> 设计者在创建 <strong>java.util.Stack</strong> 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。</p>
<p>下面将使用 <strong>StackTest.java</strong> 中的相同代码来演示这个新的 <strong>Stack</strong> 类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;StackTest2.java
import onjava.*;

public class StackTest2 &#123;
    public static void main(String[] args) &#123;
        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();
        for (String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) &#123;
            stack.push(s);
        &#125;
        while (!stack.isEmpty()) &#123;
            System.out.print(stack.pop() + &quot; &quot;);
        &#125;
    &#125;
&#125;
&#x2F;* Output:
fleas has dog My
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想在自己的代码中使用这个 <strong>Stack</strong> 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 <strong>java.util</strong> 包中的 <strong>Stack</strong> 发生冲突。例如，如果我们在上面的例子中导入 *<em>java.util.**</em>，那么就必须使用包名来防止冲突：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;StackCollision.java

public class StackCollision &#123;
  public static void main(String[] args) &#123;
    onjava.Stack&lt;String&gt; stack &#x3D; new onjava.Stack&lt;&gt;();
    for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))
      stack.push(s);
    while(!stack.isEmpty())
      System.out.print(stack.pop() + &quot; &quot;);
    System.out.println();
    java.util.Stack&lt;String&gt; stack2 &#x3D;
      new java.util.Stack&lt;&gt;();
    for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))
      stack2.push(s);
    while(!stack2.empty())
      System.out.print(stack2.pop() + &quot; &quot;);
  &#125;
&#125;
&#x2F;* Output:
fleas has dog My
fleas has dog My
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管已经有了 <strong>java.util.Stack</strong> ，但是 <strong>ArrayDeque</strong> 可以产生更好的 <strong>Stack</strong> ，因此更可取。</p>
<p>还可以使用显式导入来控制对“首选” <strong>Stack</strong> 实现的选择：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import onjava.Stack;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在,任何对 <strong>Stack</strong> 的引用都将选择 <strong>onjava</strong> 版本，而在选择 <strong>java.util.Stack</strong> 时，必须使用全限定名称（full qualification）。</p>
<h2 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h2><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p>
<p><strong>Set</strong> 具有与 <strong>Collection</strong> 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 <strong>List</strong> 那样。实际上， <strong>Set</strong> 就是一个 <strong>Collection</strong> ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为。）<strong>Set</strong> 根据对象的“值”确定归属性。</p>
<p>下面是使用存放 <strong>Integer</strong> 对象的 <strong>HashSet</strong> 的示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;SetOfInteger.java
import java.util.*;

public class SetOfInteger &#123;
    public static void main(String[] args) &#123;
        Random rand &#x3D; new Random(47);
        Set&lt;Integer&gt; intset &#x3D; new HashSet&lt;&gt;();
        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;
            intset.add(rand.nextInt(30));
        &#125;
        System.out.println(intset);
    &#125;
&#125;
&#x2F;* Output:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 0 到 29 之间的 10000 个随机整数被添加到 <strong>Set</strong> 中，因此可以想象每个值都重复了很多次。但是从结果中可以看到，每一个数只有一个实例出现在结果中。</p>
<p>早期 Java 版本中的 <strong>HashSet</strong> 产生的输出没有可辨别的顺序。这是因为出于对速度的追求， <strong>HashSet</strong> 使用了散列。由 <strong>HashSet</strong> 维护的顺序与 <strong>TreeSet</strong> 或 <strong>LinkedHashSet</strong> 不同，因为它们的实现具有不同的元素存储方式。 <strong>TreeSet</strong> 将元素存储在红-黑树数据结构中，而 <strong>HashSet</strong> 使用散列函数。 <strong>LinkedHashSet</strong> 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。看起来散列算法好像已经改变了，现在 <strong>Integer</strong> 按顺序排序。但是，您不应该依赖此行为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;SetOfString.java
import java.util.*;

public class SetOfString &#123;
  public static void main(String[] args) &#123;
    Set&lt;String&gt; colors &#x3D; new HashSet&lt;&gt;();
    for(int i &#x3D; 0; i &lt; 100; i++) &#123;
      colors.add(&quot;Yellow&quot;);
      colors.add(&quot;Blue&quot;);
      colors.add(&quot;Red&quot;);
      colors.add(&quot;Red&quot;);
      colors.add(&quot;Orange&quot;);
      colors.add(&quot;Yellow&quot;);
      colors.add(&quot;Blue&quot;);
      colors.add(&quot;Purple&quot;);
    &#125;
    System.out.println(colors);
  &#125;
&#125;
&#x2F;* Output:
[Red, Yellow, Blue, Purple, Orange]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>String</strong> 对象似乎没有排序。要对结果进行排序，一种方法是使用 <strong>TreeSet</strong> 而不是 <strong>HashSet</strong> ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;SortedSetOfString.java
import java.util.*;

public class SortedSetOfString &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; colors &#x3D; new TreeSet&lt;&gt;();
        for (int i &#x3D; 0; i &lt; 100; i++) &#123;
            colors.add(&quot;Yellow&quot;);
            colors.add(&quot;Blue&quot;);
            colors.add(&quot;Red&quot;);
            colors.add(&quot;Red&quot;);
            colors.add(&quot;Orange&quot;);
            colors.add(&quot;Yellow&quot;);
            colors.add(&quot;Blue&quot;);
            colors.add(&quot;Purple&quot;);
        &#125;
        System.out.println(colors);
    &#125;
&#125;
&#x2F;* Output:
[Blue, Orange, Purple, Red, Yellow]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最常见的操作之一是使用 <code>contains()</code> 测试成员归属性，但也有一些其它操作，这可能会让你想起在小学学过的维恩图：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;SetOperations.java
import java.util.*;

public class SetOperations &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; set1 &#x3D; new HashSet&lt;&gt;();
        Collections.addAll(set1, &quot;A B C D E F G H I J K L&quot;.split(&quot; &quot;));
        set1.add(&quot;M&quot;);
        System.out.println(&quot;H: &quot; + set1.contains(&quot;H&quot;));
        System.out.println(&quot;N: &quot; + set1.contains(&quot;N&quot;));
        Set&lt;String&gt; set2 &#x3D; new HashSet&lt;&gt;();
        Collections.addAll(set2, &quot;H I J K L&quot;.split(&quot; &quot;));
        System.out.println(&quot;set2 in set1: &quot; + set1.containsAll(set2));
        set1.remove(&quot;H&quot;);
        System.out.println(&quot;set1: &quot; + set1);
        System.out.println(&quot;set2 in set1: &quot; + set1.containsAll(set2));
        set1.removeAll(set2);
        System.out.println(&quot;set2 removed from set1: &quot; + set1);
        Collections.addAll(set1, &quot;X Y Z&quot;.split(&quot; &quot;));
        System.out.println(&quot;&#39;X Y Z&#39; added to set1: &quot; + set1);
    &#125;
&#125;
&#x2F;* Output:
H: true
N: false
set2 in set1: true
set1: [A, B, C, D, E, F, G, I, J, K, L, M]
set2 in set1: false
set2 removed from set1: [A, B, C, D, E, F, G, M]
&#39;X Y Z&#39; added to set1: [A, B, C, D, E, F, G, M, X, Y, Z]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些方法名都是自解释的，JDK 文档中还有一些其它的方法。</p>
<p>能够产生每个元素都唯一的列表是相当有用的功能。例如，假设想要列出上面的 <strong>SetOperations.java</strong> 文件中的所有单词，通过使用本书后面介绍的 <code>java.nio.file.Files.readAllLines()</code> 方法，可以打开一个文件，并将其作为一个 <strong>List&lt;String&gt;</strong> 读取，每个 <strong>String</strong> 都是输入文件中的一行：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;UniqueWords.java
import java.util.*;
import java.nio.file.*;

public class UniqueWords &#123;
    public static void main(String[] args) throws Exception &#123;
        List&lt;String&gt; lines &#x3D; Files.readAllLines(Paths.get(&quot;SetOperations.java&quot;));
        Set&lt;String&gt; words &#x3D; new TreeSet&lt;&gt;();
        for (String line : lines) &#123;
            for (String word : line.split(&quot;\\W+&quot;)) &#123;
                if (word.trim().length() &gt; 0) &#123;
                    words.add(word);
                &#125;
            &#125;
        &#125;
        System.out.println(words);
    &#125;
&#125;
&#x2F;* Output:
[A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K,
L, M, N, Output, Set, SetOperations, String, System, X,
Y, Z, add, addAll, added, args, class, collections,
contains, containsAll, false, from, import, in, java,
main, new, out, println, public, remove, removeAll,
removed, set1, set2, split, static, to, true, util,
void]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们逐步浏览文件中的每一行，并使用 <code>String.split()</code> 将其分解为单词，这里使用正则表达式 <strong>\\ W +</strong> ，这意味着它会依据一个或多个（即 <strong>+</strong> ）非单词字母来拆分字符串。每个结果单词都会添加到 <strong>Set words</strong> 中。因为它是 <strong>TreeSet</strong> ，所以对结果进行排序。这里，排序是按字典顺序（lexicographically）完成的，因此大写和小写字母位于不同的组中。如果想按字母顺序（alphabetically）对其进行排序，可以向 <strong>TreeSet</strong> 构造器传入 <strong>String.CASE_INSENSITIVE_ORDER</strong> 比较器（比较器是一个建立排序顺序的对象）：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;UniqueWordsAlphabetic.java
&#x2F;&#x2F; Producing an alphabetic listing
import java.util.*;
import java.nio.file.*;

public class UniqueWordsAlphabetic &#123;
    public static void main(String[] args) throws Exception &#123;
        List&lt;String&gt; lines &#x3D; Files.readAllLines(Paths.get(&quot;SetOperations.java&quot;));
        Set&lt;String&gt; words &#x3D; new TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);
        for (String line : lines) &#123;
            for (String word : line.split(&quot;\\W+&quot;)) &#123;
                if (word.trim().length() &gt; 0) &#123;
                    words.add(word);
                &#125;
            &#125;
        &#125;
        System.out.println(words);
    &#125;
&#125;
&#x2F;* Output:
[A, add, addAll, added, args, B, C, class, collections,
contains, containsAll, D, E, F, false, from, G, H,
HashSet, I, import, in, J, java, K, L, M, main, N, new,
out, Output, println, public, remove, removeAll,
removed, Set, set1, set2, SetOperations, split, static,
String, System, to, true, util, void, X, Y, Z]
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h2><p>将对象映射到其他对象的能力是解决编程问题的有效方法。例如，考虑一个程序，它被用来检查 Java 的 <strong>Random</strong> 类的随机性。理想情况下， <strong>Random</strong> 会产生完美的数字分布，但为了测试这一点，则需要生成大量的随机数，并计算落在各种范围内的数字个数。 <strong>Map</strong> 可以很容易地解决这个问题。在本例中，键是 <strong>Random</strong> 生成的数字，而值是该数字出现的次数：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;Statistics.java
&#x2F;&#x2F; Simple demonstration of HashMap
import java.util.*;

public class Statistics &#123;
  public static void main(String[] args) &#123;
    Random rand &#x3D; new Random(47);
    Map&lt;Integer, Integer&gt; m &#x3D; new HashMap&lt;&gt;();
    for(int i &#x3D; 0; i &lt; 10000; i++) &#123;
      &#x2F;&#x2F; Produce a number between 0 and 20:
      int r &#x3D; rand.nextInt(20);
      Integer freq &#x3D; m.get(r); &#x2F;&#x2F; [1]
      m.put(r, freq &#x3D;&#x3D; null ? 1 : freq + 1);
    &#125;
    System.out.println(m);
  &#125;
&#125;
&#x2F;* Output:
&#123;0&#x3D;481, 1&#x3D;502, 2&#x3D;489, 3&#x3D;508, 4&#x3D;481, 5&#x3D;503, 6&#x3D;519,
7&#x3D;471, 8&#x3D;468, 9&#x3D;549, 10&#x3D;513, 11&#x3D;531, 12&#x3D;521, 13&#x3D;506,
14&#x3D;477, 15&#x3D;497, 16&#x3D;533, 17&#x3D;509, 18&#x3D;478, 19&#x3D;464&#125;
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>[1]**自动包装机制将随机生成的 **int</strong> 转换为可以与 <strong>HashMap</strong> 一起使用的 <strong>Integer</strong> 引用（不能使用基本类型的集合）。如果键不在集合中，则 <code>get()</code> 返回 <strong>null</strong> （这意味着该数字第一次出现）。否则， <code>get()</code> 会为键生成与之关联的 <strong>Integer</strong> 值，然后该值被递增（自动包装机制再次简化了表达式，但实际上确实发生了对 <strong>Integer</strong> 的装箱和拆箱）。</p>
<p>接下来的示例将使用一个 <strong>String</strong> 描述来查找 <strong>Pet</strong> 对象。它还展示了通过使用 <code>containsKey()</code> 和 <code>containsValue()</code> 方法去测试一个 <strong>Map</strong> ，以查看它是否包含某个键或某个值：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;PetMap.java
import typeinfo.pets.*;
import java.util.*;

public class PetMap &#123;
  public static void main(String[] args) &#123;
    Map&lt;String, Pet&gt; petMap &#x3D; new HashMap&lt;&gt;();
    petMap.put(&quot;My Cat&quot;, new Cat(&quot;Molly&quot;));
    petMap.put(&quot;My Dog&quot;, new Dog(&quot;Ginger&quot;));
    petMap.put(&quot;My Hamster&quot;, new Hamster(&quot;Bosco&quot;));
    System.out.println(petMap);
    Pet dog &#x3D; petMap.get(&quot;My Dog&quot;);
    System.out.println(dog);
    System.out.println(petMap.containsKey(&quot;My Dog&quot;));
    System.out.println(petMap.containsValue(dog));
  &#125;
&#125;
&#x2F;* Output:
&#123;My Dog&#x3D;Dog Ginger, My Cat&#x3D;Cat Molly, My Hamster&#x3D;Hamster Bosco&#125;
Dog Ginger
true
true
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Map</strong> 与数组和其他的 <strong>Collection</strong> 一样，可以轻松地扩展到多个维度，只需要创建一个值为 <strong>Map</strong> 的 <strong>Map</strong>（这些 <strong>Map</strong> 的值可以是其他集合，甚至是其他 <strong>Map</strong>）。因此，能够很容易地将集合组合起来以快速生成强大的数据结构。例如，假设你正在追踪有多个宠物的人，只需要一个 <strong>Map&lt;Person, List&lt;Pet&gt;&gt;</strong> 即可：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;MapOfList.java
&#x2F;&#x2F; &#123;java collections.MapOfList&#125;
package collections;
import typeinfo.pets.*;
import java.util.*;

public class MapOfList &#123;
    public static final Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople &#x3D; new HashMap&lt;&gt;();

    static &#123;
        petPeople.put(new Person(&quot;Dawn&quot;),
                Arrays.asList(
                        new Cymric(&quot;Molly&quot;),
                        new Mutt(&quot;Spot&quot;)));
        petPeople.put(new Person(&quot;Kate&quot;),
                Arrays.asList(
                        new Cat(&quot;Shackleton&quot;),
                        new Cat(&quot;Elsie May&quot;),
                        new Dog(&quot;Margrett&quot;)));
        petPeople.put(new Person(&quot;Marilyn&quot;),
                Arrays.asList(
                        new Pug(&quot;Louie aka Louis Snorkelstein Dupree&quot;),
                        new Cat(&quot;Stanford&quot;),
                        new Cat(&quot;Pinkola&quot;)));
        petPeople.put(new Person(&quot;Luke&quot;),
                Arrays.asList(
                        new Rat(&quot;Fuzzy&quot;),
                        new Rat(&quot;Fizzy&quot;)));
        petPeople.put(new Person(&quot;Isaac&quot;),
                Arrays.asList(new Rat(&quot;Freckly&quot;)));
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(&quot;People: &quot; + petPeople.keySet());
        System.out.println(&quot;Pets: &quot; + petPeople.values());
        for (Person person : petPeople.keySet()) &#123;
            System.out.println(person + &quot; has:&quot;);
            for (Pet pet : petPeople.get(person)) &#123;
                System.out.println(&quot;    &quot; + pet);
            &#125;
        &#125;
    &#125;
&#125;
&#x2F;* Output:
People: [Person Dawn, Person Kate, Person Isaac, Person Marilyn, Person Luke]
Pets: [[Cymric Molly, Mutt Spot], [Cat Shackleton, Cat Elsie May, Dog Margrett], [Rat Freckly], [Pug Louie aka Louis Snorkelstein Dupree, Cat Stanford, Cat Pinkola],[Rat Fuzzy, Rat Fizzy]]
Person Dawn has:
    Cymric Molly
    Mutt Spot
Person Kate has:
    Cat Shackleton
    Cat Elsie May
    Dog Margrett
Person Isaac has:
    Rat Freckly
Person Marilyn has:
    Pug Louie aka Louis Snorkelstein Dupree
    Cat Stanford
    Cat Pinkola
Person Luke has:
    Rat Fuzzy
    Rat Fizzy
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Map</strong> 可以返回由其键组成的 <strong>Set</strong> ，由其值组成的 <strong>Collection</strong> ，或者其键值对的 <strong>Set</strong> 。 <code>keySet()</code> 方法生成由在 <strong>petPeople</strong> 中的所有键组成的 <strong>Set</strong> ，它在 for-in 语句中被用来遍历该 <strong>Map</strong> 。</p>
<h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><p>队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。</p>
<p><strong>LinkedList</strong> 实现了 <strong>Queue</strong> 接口，并且提供了一些方法以支持队列行为，因此 <strong>LinkedList</strong> 可以用作 <strong>Queue</strong> 的一种实现。 通过将 <strong>LinkedList</strong> 向上转换为 <strong>Queue</strong> ，下面的示例使用了在 <strong>Queue</strong> 接口中与 <strong>Queue</strong> 相关(Queue-specific)的方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;QueueDemo.java
&#x2F;&#x2F; Upcasting to a Queue from a LinkedList
import java.util.*;

public class QueueDemo &#123;
    public static void printQ(Queue queue) &#123;
        while (queue.peek() !&#x3D; null) &#123;
            System.out.print(queue.remove() + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;

    public static void main(String[] args) &#123;
        Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();
        Random rand &#x3D; new Random(47);
        for (int i &#x3D; 0; i &lt; 10; i++) &#123;
            queue.offer(rand.nextInt(i + 10));
        &#125;
        printQ(queue);
        Queue&lt;Character&gt; qc &#x3D; new LinkedList&lt;&gt;();
        for (char c : &quot;Brontosaurus&quot;.toCharArray()) &#123;
            qc.offer(c);
        &#125;
        printQ(qc);
    &#125;
&#125;
&#x2F;* Output:
8 1 1 1 5 14 3 1 0 1
B r o n t o s a u r u s
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>offer()</code> 是与 <strong>Queue</strong> 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。 <code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 <code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</p>
<p>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象。 <strong>Queue</strong> 接口窄化了对 <strong>LinkedList</strong> 方法的访问权限，因此只有适当的方法才能使用，因此能够访问到的 <strong>LinkedList</strong> 的方法会变少（这里实际上可以将 <strong>Queue</strong> 强制转换回 <strong>LinkedList</strong> ，但至少我们不鼓励这样做）。</p>
<p>TODO ：不了解自动包装机制。2020年10月13日</p>
<p>与 <strong>Queue</strong> 相关的方法提供了完整而独立的功能。 也就是说，对于 <strong>Queue</strong> 所继承的 <strong>Collection</strong> ，在不需要使用它的任何方法的情况下，就可以拥有一个可用的 <strong>Queue</strong> 。</p>
<h2 id="优先级队列PriorityQueue"><a href="#优先级队列PriorityQueue" class="headerlink" title="优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h2><p>先进先出（FIFO）描述了最典型的队列规则（queuing discipline）。队列规则是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个弹出的元素应该是等待时间最长的元素。</p>
<p>优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。例如，在机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息传递系统，某些消息比其他消息更重要，应该尽快处理，而不管它们何时到达。在Java 5 中添加了 <strong>PriorityQueue</strong> ，以便自动实现这种行为。</p>
<p>当在 <strong>PriorityQueue</strong> 上调用 <code>offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。默认的排序使用队列中对象的自然顺序（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p>
<p>让 <strong>PriorityQueue</strong> 与 <strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 这样的内置类型一起工作易如反掌。在下面的示例中，第一组值与前一个示例中的随机值相同，可以看到它们从 <strong>PriorityQueue</strong> 中弹出的顺序与前一个示例不同：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;PriorityQueueDemo.java
import java.util.*;

public class PriorityQueueDemo &#123;
    public static void main(String[] args) &#123;
        PriorityQueue&lt;Integer&gt; priorityQueue &#x3D; new PriorityQueue&lt;&gt;();
        Random rand &#x3D; new Random(47);
        for (int i &#x3D; 0; i &lt; 10; i++) &#123;
            priorityQueue.offer(rand.nextInt(i + 10));
        &#125;
        QueueDemo.printQ(priorityQueue);

        List&lt;Integer&gt; ints &#x3D; Arrays.asList(25, 22, 20, 18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25);
        priorityQueue &#x3D; new PriorityQueue&lt;&gt;(ints);
        QueueDemo.printQ(priorityQueue);
        priorityQueue &#x3D; new PriorityQueue&lt;&gt;(ints.size(), Collections.reverseOrder());
        priorityQueue.addAll(ints);
        QueueDemo.printQ(priorityQueue);

        String fact &#x3D; &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;;
        List&lt;String&gt; strings &#x3D; Arrays.asList(fact.split(&quot;&quot;));
        PriorityQueue&lt;String&gt; stringPQ &#x3D; new PriorityQueue&lt;&gt;(strings);
        QueueDemo.printQ(stringPQ);
        stringPQ &#x3D; new PriorityQueue&lt;&gt;(strings.size(), Collections.reverseOrder());
        stringPQ.addAll(strings);
        QueueDemo.printQ(stringPQ);

        Set&lt;Character&gt; charSet &#x3D; new HashSet&lt;&gt;();
        for (char c : fact.toCharArray()) &#123;
            charSet.add(c); &#x2F;&#x2F; Autoboxing
        &#125;
        PriorityQueue&lt;Character&gt; characterPQ &#x3D; new PriorityQueue&lt;&gt;(charSet);
        QueueDemo.printQ(characterPQ);
    &#125;
&#125;
&#x2F;* Output:
0 1 1 1 1 1 3 5 8 14 
1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25 
25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1 
      A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U W 
W U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A       
  A B C D E F H I L N O S T U W 
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>PriorityQueue</strong> 是允许重复的，最小的值具有最高的优先级（如果是 <strong>String</strong> ，空格也可以算作值，并且比字母的优先级高）。为了展示如何通过提供自己的 <strong>Comparator</strong> 对象来改变顺序，第三个对 <strong>PriorityQueue&lt;Integer&gt;</strong> 构造器的调用，和第二个对 <strong>PriorityQueue&lt;String&gt;</strong> 的调用使用了由 <code>Collections.reverseOrder()</code> （Java 5 中新添加的）产生的反序的 <strong>Comparator</strong> 。</p>
<p>最后一部分添加了一个 <strong>HashSet</strong> 来消除重复的 <strong>Character</strong>。</p>
<p><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</p>
<h2 id="集合与迭代器"><a href="#集合与迭代器" class="headerlink" title="集合与迭代器"></a>集合与迭代器</h2><p>TODO ：本节有许多问题不理解，需要巩固。2020年10月13日</p>
<p><strong>Collection</strong> 是所有序列集合共有的根接口。它可能会被认为是一种“附属接口”（incidental interface），即因为要表示其他若干个接口的共性而出现的接口。此外，<strong>java.util.AbstractCollection</strong> 类提供了 <strong>Collection</strong> 的默认实现，使得你可以创建 <strong>AbstractCollection</strong> 的子类型，而其中没有不必要的代码重复。</p>
<p>使用接口描述的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。因此，如果所编写的方法接受一个 <strong>Collection</strong> ，那么该方法可以应用于任何实现了 <strong>Collection</strong> 的类——这也就使得一个新类可以选择去实现 <strong>Collection</strong> 接口，以便该方法可以使用它。标准 C++ 类库中的集合并没有共同的基类——集合之间的所有共性都是通过迭代器实现的。在 Java 中，遵循 C++ 的方式看起来似乎很明智，即用迭代器而不是 <strong>Collection</strong> 来表示集合之间的共性。但是，这两种方法绑定在了一起，因为实现 <strong>Collection</strong> 就意味着需要提供 <code>iterator()</code> 方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;InterfaceVsIterator.java
import typeinfo.pets.*;
import java.util.*;

public class InterfaceVsIterator &#123;
    public static void display(Iterator&lt;Pet&gt; it) &#123;
        while (it.hasNext()) &#123;
            Pet p &#x3D; it.next();
            System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;

    public static void display(Collection&lt;Pet&gt; pets) &#123;
        for (Pet p : pets) &#123;
            System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;

    public static void main(String[] args) &#123;
        List&lt;Pet&gt; petList &#x3D; Pets.list(8);
        Set&lt;Pet&gt; petSet &#x3D; new HashSet&lt;&gt;(petList);
        Map&lt;String, Pet&gt; petMap &#x3D; new LinkedHashMap&lt;&gt;();
        String[] names &#x3D; (&quot;Ralph, Eric, Robin, Lacey, &quot; + &quot;Britney, Sam, Spot, Fluffy&quot;).split(&quot;, &quot;);
        for (int i &#x3D; 0; i &lt; names.length; i++) &#123;
            petMap.put(names[i], petList.get(i));
        &#125;
        display(petList);
        display(petSet);
        display(petList.iterator());
        display(petSet.iterator());
        System.out.println(petMap);
        System.out.println(petMap.keySet());
        display(petMap.values());
        display(petMap.values().iterator());
    &#125;
&#125;
&#x2F;* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
&#123;Ralph&#x3D;Rat, Eric&#x3D;Manx, Robin&#x3D;Cymric, Lacey&#x3D;Mutt, Britney&#x3D;Pug, Sam&#x3D;Cymric, Spot&#x3D;Pug, Fluffy&#x3D;Manx&#125;
[Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy]
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两个版本的 <code>display()</code> 方法都可以使用 <strong>Map</strong> 或 <strong>Collection</strong> 的子类型来工作。 而且<strong>Collection</strong> 接口和 <strong>Iterator</strong> 都将 <code>display()</code> 方法与低层集合的特定实现解耦。</p>
<p>在本例中，这两种方式都可以奏效。事实上， <strong>Collection</strong> 要更方便一点，因为它是 <strong>Iterable</strong> 类型，因此在 <code>display(Collection)</code> 的实现中可以使用 for-in 构造，这使得代码更加清晰。</p>
<p>当需要实现一个不是 <strong>Collection</strong> 的外部类时，由于让它去实现 <strong>Collection</strong> 接口可能非常困难或麻烦，因此使用 <strong>Iterator</strong> 就会变得非常吸引人。例如，如果我们通过继承一个持有 <strong>Pet</strong> 对象的类来创建一个 <strong>Collection</strong> 的实现，那么我们必须实现 <strong>Collection</strong> 所有的方法，即使我们不在 <code>display()</code> 方法中使用它们，也必须这样做。虽然这可以通过继承 <strong>AbstractCollection</strong> 而很容易地实现，但是无论如何还是要被强制去实现 <code>iterator()</code> 和 <code>size()</code> 方法，这些方法 <strong>AbstractCollection</strong> 没有实现，但是 <strong>AbstractCollection</strong> 中的其它方法会用到：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;CollectionSequence.java
import typeinfo.pets.*;
import java.util.*;

public class CollectionSequence extends AbstractCollection&lt;Pet&gt; &#123;
    private Pet[] pets &#x3D; Pets.array(8);

    @Override
    public int size() &#123;
        return pets.length;
    &#125;

    @Override
    public Iterator&lt;Pet&gt; iterator() &#123;
        return new Iterator&lt;Pet&gt;() &#123; &#x2F;&#x2F; [1]
            private int index &#x3D; 0;

            @Override
            public boolean hasNext() &#123;
                return index &lt; pets.length;
            &#125;

            @Override
            public Pet next() &#123;
                return pets[index++];
            &#125;

            @Override
            public void remove() &#123; &#x2F;&#x2F; Not implemented
                throw new UnsupportedOperationException();
            &#125;
        &#125;;
    &#125;

    public static void main(String[] args) &#123;
        CollectionSequence c &#x3D; new CollectionSequence();
        InterfaceVsIterator.display(c);
        InterfaceVsIterator.display(c.iterator());
    &#125;
&#125;
&#x2F;* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>remove()</code> 方法是一个“可选操作”。 这里可以不必实现它，如果你调用它，它将抛出异常。</p>
<p><strong>[1]</strong> 你可能会认为，因为 <code>iterator()</code> 返回 <strong>Iterator&lt;Pet&gt;</strong> ，匿名内部类定义可以使用菱形语法，Java可以推断出类型。但这不起作用，类型推断仍然非常有限。</p>
<p>这个例子表明，如果实现了 <strong>Collection</strong> ，就必须实现 <code>iterator()</code> ，并且只拿实现 <code>iterator()</code> 与继承 <strong>AbstractCollection</strong> 相比，花费的代价只有略微减少。但是，如果类已经继承了其他的类，那么就不能再继承 <strong>AbstractCollection</strong> 了。在这种情况下，要实现 <strong>Collection</strong> ，就必须实现该接口中的所有方法。此时，继承并提供创建迭代器的能力要容易得多：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;NonCollectionSequence.java
import typeinfo.pets.*;
import java.util.*;

class PetSequence &#123;
  protected Pet[] pets &#x3D; Pets.array(8);
&#125;

public class NonCollectionSequence extends PetSequence &#123;
  public Iterator&lt;Pet&gt; iterator() &#123;
    return new Iterator&lt;Pet&gt;() &#123;
      private int index &#x3D; 0;
      @Override
      public boolean hasNext() &#123;
        return index &lt; pets.length;
      &#125;
      @Override
      public Pet next() &#123; return pets[index++]; &#125;
      @Override
      public void remove() &#123; &#x2F;&#x2F; Not implemented
        throw new UnsupportedOperationException();
      &#125;
    &#125;;
  &#125;
  public static void main(String[] args) &#123;
    NonCollectionSequence nc &#x3D;
      new NonCollectionSequence();
    InterfaceVsIterator.display(nc.iterator());
  &#125;
&#125;
&#x2F;* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug
7:Manx
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成 <strong>Iterator</strong> 是将序列与消费该序列的方法连接在一起耦合度最小的方式，并且与实现 <strong>Collection</strong> 相比，它在序列类上所施加的约束也少得多。</p>
<h2 id="for-in和迭代器"><a href="#for-in和迭代器" class="headerlink" title="for-in和迭代器"></a>for-in和迭代器</h2><p>到目前为止，for-in 语法主要用于数组，但它也适用于任何 <strong>Collection</strong> 对象。实际上在使用 <strong>ArrayList</strong> 时，已经看到了一些使用它的示例，下面是一个更通用的证明：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;ForInCollections.java
&#x2F;&#x2F; All collections work with for-in
import java.util.*;

public class ForInCollections &#123;
    public static void main(String[] args) &#123;
        Collection&lt;String&gt; cs &#x3D; new LinkedList&lt;&gt;();
        Collections.addAll(cs, &quot;Take the long way home&quot;.split(&quot; &quot;));
        for (String s : cs) &#123;
            System.out.print(&quot;&#39;&quot; + s + &quot;&#39; &quot;);
        &#125;
    &#125;
&#125;
&#x2F;* Output:
&#39;Take&#39; &#39;the&#39; &#39;long&#39; &#39;way&#39; &#39;home&#39;
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 <strong>cs</strong> 是一个 <strong>Collection</strong> ，因此该代码展示了使用 for-in 是所有 <strong>Collection</strong> 对象的特征。</p>
<p>这样做的原因是 Java 5 引入了一个名为 <strong>Iterable</strong> 的接口，该接口包含一个能够生成 <strong>Iterator</strong> 的 <code>iterator()</code> 方法。for-in 使用此 <strong>Iterable</strong> 接口来遍历序列。因此，如果创建了任何实现了 <strong>Iterable</strong> 的类，都可以将它用于 for-in 语句中：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;IterableClass.java
&#x2F;&#x2F; Anything Iterable works with for-in
import java.util.*;

public class IterableClass implements Iterable&lt;String&gt; &#123;
    protected String[] words &#x3D; (&quot;And that is how &quot; +
            &quot;we know the Earth to be banana-shaped.&quot;
    ).split(&quot; &quot;);

    @Override
    public Iterator&lt;String&gt; iterator() &#123;
        return new Iterator&lt;String&gt;() &#123;
            private int index &#x3D; 0;

            @Override
            public boolean hasNext() &#123;
                return index &lt; words.length;
            &#125;

            @Override
            public String next() &#123;
                return words[index++];
            &#125;

            @Override
            public void remove() &#123; &#x2F;&#x2F; Not implemented
                throw new UnsupportedOperationException();
            &#125;
        &#125;;
    &#125;

    public static void main(String[] args) &#123;
        for (String s : new IterableClass()) &#123;
            System.out.print(s + &quot; &quot;);
        &#125;
    &#125;
&#125;
&#x2F;* Output:
And that is how we know the Earth to be banana-shaped.
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>iterator()</code> 返回的是实现了 <strong>Iterator&lt;String&gt;</strong> 的匿名内部类的实例，该匿名内部类可以遍历数组中的每个单词。在主方法中，可以看到 <strong>IterableClass</strong> 确实可以用于 for-in 语句。</p>
<p>在 Java 5 中，许多类都是 <strong>Iterable</strong> ，主要包括所有的 <strong>Collection</strong> 类（但不包括各种 <strong>Maps</strong> ）。 例如，下面的代码可以显示所有的操作系统环境变量：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;EnvironmentVariables.java
&#x2F;&#x2F; &#123;VisuallyInspectOutput&#125;
import java.util.*;

public class EnvironmentVariables &#123;
  public static void main(String[] args) &#123;
    for(Map.Entry entry: System.getenv().entrySet()) &#123;
      System.out.println(entry.getKey() + &quot;: &quot; +
        entry.getValue());
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TODO ：未学完。2020年10月13日</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java 提供了许多保存对象的方法：</p>
<ol>
<li>数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。</li>
<li><strong>Collection</strong> 保存单一的元素，而 <strong>Map</strong> 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 <strong>Collection</strong> 和各种 <strong>Map</strong> 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</li>
<li>像数组一样， <strong>List</strong> 也将数字索引与对象相关联，因此，数组和 <strong>List</strong> 都是有序集合。</li>
<li>如果要执行大量的随机访问，则使用 <strong>ArrayList</strong> ，如果要经常从表中间插入或删除元素，则应该使用 <strong>LinkedList</strong> 。</li>
<li>队列和堆栈的行为是通过 <strong>LinkedList</strong> 提供的。</li>
<li><strong>Map</strong> 是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
<li><strong>Set</strong> 不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>
<li>不要在新代码中使用遗留类 <strong>Vector</strong> ，<strong>Hashtable</strong> 和 <strong>Stack</strong> 。</li>
</ol>
<p>Java 集合框架简图，黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。</p>
<p>![collection](E:\OneDrive - lanqilu\我的图片库\blogimg\Java持有对象\collection.png)![map](E:\OneDrive - lanqilu\我的图片库\blogimg\Java持有对象\map.png)</p>
<h3 id="简单集合分类"><a href="#简单集合分类" class="headerlink" title="简单集合分类"></a>简单集合分类</h3><p>可以看到，实际上只有四个基本的集合组件： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> ，它们各有两到三个实现版本（<strong>Queue</strong> 的 <strong>java.util.concurrent</strong> 实现未包含在此图中）。最常使用的集合用黑色粗线线框表示。</p>
<p>虚线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的虚线表示特定的类实现了一个接口。实心箭头表示某个类可以生成箭头指向的类的对象。例如，任何 <strong>Collection</strong> 都可以生成 <strong>Iterator</strong> ， <strong>List</strong> 可以生成 <strong>ListIterator</strong> （也能生成普通的 <strong>Iterator</strong> ，因为 <strong>List</strong> 继承自 <strong>Collection</strong> ）。</p>
<p>下面的示例展示了各种不同的类在方法上的差异。程序的输出还展示了在每个类或接口中所实现的接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; collections&#x2F;CollectionDifferences.java
import onjava.*;

public class CollectionDifferences &#123;
  public static void main(String[] args) &#123;
    CollectionMethodDifferences.main(args);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除 <strong>TreeSet</strong> 之外的所有 <strong>Set</strong> 都具有与 <strong>Collection</strong> 完全相同的接口。<strong>List</strong> 和 <strong>Collection</strong> 存在着明显的不同，尽管 <strong>List</strong> 所要求的方法都在 <strong>Collection</strong> 中。另一方面，在 <strong>Queue</strong> 接口中的方法是独立的，在创建具有 <strong>Queue</strong> 功能的实现时，不需要使用 <strong>Collection</strong> 方法。最后， <strong>Map</strong> 和 <strong>Collection</strong> 之间唯一的交集是 <strong>Map</strong> 可以使用 <code>entrySet()</code> 和 <code>values()</code> 方法来产生 <strong>Collection</strong> 。</p>
<p>请注意，标记接口 <strong>java.util.RandomAccess</strong> 附加到了 <strong>ArrayList</strong> 上，但不附加到 <strong>LinkedList</strong> 上。这为根据特定 <strong>List</strong> 动态改变其行为的算法提供了信息。</p>
<p>从面向对象的继承层次结构来看，这种组织结构确实有些奇怪。但是，当了解了 <strong>java.util</strong> 中更多的有关集合的内容后，就会发现除了继承结构有点奇怪外，还有更多的问题。集合类库一直以来都是设计难题——解决这些问题涉及到要去满足经常彼此之间互为牵制的各方面需求。所以要做好准备，在各处做出妥协。</p>
<p>尽管存在这些问题，但 Java 集合仍是在日常工作中使用的基本工具，它可以使程序更简洁、更强大、更有效。你可能需要一段时间才能熟悉集合类库的某些方面，但我想你很快就会找到自己的路子，来获得和使用这个类库中的类。</p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/10/14/Java-05-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/medias/featureimages/11.jpg" class="responsive-img" alt="Java函数式编程">
                        
                        <span class="card-title">Java函数式编程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-10-14
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-category">
                                    函数式编程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
                        <span class="chip bg-color">函数式编程</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/08/08/Java-03-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/medias/featureimages/8.png" class="responsive-img" alt="Java类型系统">
                        
                        <span class="card-title">Java类型系统</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-08-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2020</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Lanqulu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
       
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/Lanqilu/Lanqilu.github.io@0.2/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
